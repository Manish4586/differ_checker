From 5a0cc3df7a9070d39e0f2ce4b7881b3a68b1174f Mon Sep 17 00:00:00 2001
From: Manish4586 <manish.n.manish45@gmail.com>
Date: Thu, 6 Jun 2019 20:59:40 +0530
Subject: [PATCH] sdm660-common: usb: update hals to 1.1 from android-9.0.0_r42

Signed-off-by: Manish4586 <manish.n.manish45@gmail.com>

 Changes to be committed:
	modified:   platform.mk
	modified:   usb/Android.bp
	modified:   usb/Usb.cpp
	modified:   usb/Usb.h
	new file:   usb/UsbGadget.cpp
	new file:   usb/UsbGadget.h
	deleted:    usb/android.hardware.usb@1.0-service.xiaomi_sdm660.rc
	new file:   usb/android.hardware.usb@1.1-service.xiaomi_sdm660.rc
	modified:   usb/service.cpp
---
 platform.mk                                   |   2 +-
 usb/Android.bp                                |  14 +-
 usb/Usb.cpp                                   | 733 ++++++++++++++++--
 usb/Usb.h                                     |  57 +-
 usb/UsbGadget.cpp                             | 650 ++++++++++++++++
 usb/UsbGadget.h                               | 103 +++
 ....hardware.usb@1.0-service.xiaomi_sdm660.rc |   4 -
 ....hardware.usb@1.1-service.xiaomi_sdm660.rc |  12 +
 usb/service.cpp                               |  69 +-
 9 files changed, 1532 insertions(+), 112 deletions(-)
 create mode 100644 usb/UsbGadget.cpp
 create mode 100644 usb/UsbGadget.h
 delete mode 100644 usb/android.hardware.usb@1.0-service.xiaomi_sdm660.rc
 create mode 100644 usb/android.hardware.usb@1.1-service.xiaomi_sdm660.rc

diff --git a/platform.mk b/platform.mk
index e2986fe..7e271dc 100644
--- a/platform.mk
+++ b/platform.mk
@@ -388,7 +388,7 @@ PRODUCT_PACKAGES += \
 
 # USB
 PRODUCT_PACKAGES += \
-	android.hardware.usb@1.0-service.xiaomi_sdm660
+	android.hardware.usb@1.1-service.xiaomi_sdm660
 
 # Video seccomp policy files
 PRODUCT_COPY_FILES += \
diff --git a/usb/Android.bp b/usb/Android.bp
index 7263f0e..c323331 100644
--- a/usb/Android.bp
+++ b/usb/Android.bp
@@ -1,5 +1,5 @@
 //
-// Copyright (C) 2018 The Xiaomi-SDM660 Project
+// Copyright (C) 2017 The Android Open Source Project
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -13,19 +13,21 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 cc_binary {
-    name: "android.hardware.usb@1.0-service.xiaomi_sdm660",
+    name: "android.hardware.usb@1.1-service.xiaomi_sdm660",
     relative_install_path: "hw",
-    init_rc: ["android.hardware.usb@1.0-service.xiaomi_sdm660.rc"],
-    srcs: ["service.cpp", "Usb.cpp"],
+    init_rc: ["android.hardware.usb@1.1-service.xiaomi_sdm660.rc"],
+    srcs: ["service.cpp", "Usb.cpp", "UsbGadget.cpp"],
     shared_libs: [
         "libbase",
-        "libcutils",
         "libhidlbase",
         "libhidltransport",
-        "libhwbinder",
+        "liblog",
         "libutils",
         "libhardware",
         "android.hardware.usb@1.0",
+        "android.hardware.usb@1.1",
+	"android.hardware.usb.gadget@1.0",
+        "libcutils",
     ],
     proprietary: true,
 }
diff --git a/usb/Usb.cpp b/usb/Usb.cpp
index 44e2775..2bf7d21 100644
--- a/usb/Usb.cpp
+++ b/usb/Usb.cpp
@@ -1,33 +1,35 @@
 /*
-#
-# Copyright (C) 2018 The Xiaomi-SDM660 Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-#
-# This file sets variables that control the way modules are built
-# thorughout the system. It should not be used to conditionally
-# disable makefiles (the proper mechanism to control what gets
-# included in a build is to use PRODUCT_PACKAGES in a product
-# definition file).
-#
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
+
+#define LOG_TAG "android.hardware.usb@1.1-service.xiaomi_sdm660"
+
+#include <android-base/logging.h>
+#include <assert.h>
+#include <chrono>
+#include <dirent.h>
 #include <pthread.h>
+#include <regex>
 #include <stdio.h>
 #include <sys/types.h>
+#include <thread>
 #include <unistd.h>
+#include <unordered_map>
 
-#include <android-base/logging.h>
+#include <cutils/uevent.h>
+#include <sys/epoll.h>
 #include <utils/Errors.h>
 #include <utils/StrongPointer.h>
 
@@ -36,51 +38,676 @@
 namespace android {
 namespace hardware {
 namespace usb {
-namespace V1_0 {
+namespace V1_1 {
 namespace implementation {
 
-Return<void> Usb::switchRole(const hidl_string &portName __unused,
-                             const PortRole &newRole __unused) {
-    LOG(ERROR) << __func__ << ": Not supported";
+// Set by the signal handler to destroy the thread
+volatile bool destroyThread;
+
+int32_t readFile(const std::string &filename, std::string *contents) {
+  FILE *fp;
+  ssize_t read = 0;
+  char *line = NULL;
+  size_t len = 0;
+
+  fp = fopen(filename.c_str(), "r");
+  if (fp != NULL) {
+    if ((read = getline(&line, &len, fp)) != -1) {
+      char *pos;
+      if ((pos = strchr(line, '\n')) != NULL) *pos = '\0';
+      *contents = line;
+    }
+    free(line);
+    fclose(fp);
+    return 0;
+  } else {
+    ALOGE("fopen failed");
+  }
+
+  return -1;
+}
+
+std::string appendRoleNodeHelper(const std::string &portName,
+                                 PortRoleType type) {
+  std::string node("/sys/class/typec/" + portName);
+
+  switch (type) {
+    case PortRoleType::DATA_ROLE:
+      return node + "/data_role";
+    case PortRoleType::POWER_ROLE:
+      return node + "/power_role";
+    case PortRoleType::MODE:
+      return node + "/port_type";
+    default:
+      return "";
+  }
+}
+
+std::string convertRoletoString(PortRole role) {
+  if (role.type == PortRoleType::POWER_ROLE) {
+    if (role.role == static_cast<uint32_t>(PortPowerRole::SOURCE))
+      return "source";
+    else if (role.role == static_cast<uint32_t>(PortPowerRole::SINK))
+      return "sink";
+  } else if (role.type == PortRoleType::DATA_ROLE) {
+    if (role.role == static_cast<uint32_t>(PortDataRole::HOST)) return "host";
+    if (role.role == static_cast<uint32_t>(PortDataRole::DEVICE))
+      return "device";
+  } else if (role.type == PortRoleType::MODE) {
+    if (role.role == static_cast<uint32_t>(PortMode_1_1::UFP)) return "sink";
+    if (role.role == static_cast<uint32_t>(PortMode_1_1::DFP)) return "source";
+  }
+  return "none";
+}
+
+void extractRole(std::string *roleName) {
+  std::size_t first, last;
+
+  first = roleName->find("[");
+  last = roleName->find("]");
+
+  if (first != std::string::npos && last != std::string::npos) {
+    *roleName = roleName->substr(first + 1, last - first - 1);
+  }
+}
+
+void switchToDrp(const std::string &portName) {
+  std::string filename =
+      appendRoleNodeHelper(std::string(portName.c_str()), PortRoleType::MODE);
+  FILE *fp;
+
+  if (filename != "") {
+    fp = fopen(filename.c_str(), "w");
+    if (fp != NULL) {
+      int ret = fputs("dual", fp);
+      fclose(fp);
+      if (ret == EOF)
+        ALOGE("Fatal: Error while switching back to drp");
+    } else {
+      ALOGE("Fatal: Cannot open file to switch back to drp");
+    }
+  } else {
+    ALOGE("Fatal: invalid node type");
+  }
+}
+
+bool switchMode(const hidl_string &portName,
+                             const PortRole &newRole, struct Usb *usb) {
+  std::string filename =
+       appendRoleNodeHelper(std::string(portName.c_str()), newRole.type);
+  std::string written;
+  FILE *fp;
+  bool roleSwitch = false;
+
+  if (filename == "") {
+    ALOGE("Fatal: invalid node type");
+    return false;
+  }
+
+  fp = fopen(filename.c_str(), "w");
+  if (fp != NULL) {
+    // Hold the lock here to prevent loosing connected signals
+    // as once the file is written the partner added signal
+    // can arrive anytime.
+    pthread_mutex_lock(&usb->mPartnerLock);
+    usb->mPartnerUp = false;
+    int ret = fputs(convertRoletoString(newRole).c_str(), fp);
+    fclose(fp);
+
+    if (ret != EOF) {
+      struct timespec   to;
+      struct timespec   now;
+
+wait_again:
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      to.tv_sec = now.tv_sec + PORT_TYPE_TIMEOUT;
+      to.tv_nsec = now.tv_nsec;
+
+      int err = pthread_cond_timedwait(&usb->mPartnerCV, &usb->mPartnerLock, &to);
+      // There are no uevent signals which implies role swap timed out.
+      if (err == ETIMEDOUT) {
+        ALOGI("uevents wait timedout");
+      // Sanity check.
+      } else if (!usb->mPartnerUp) {
+        goto wait_again;
+      // Role switch succeeded since usb->mPartnerUp is true.
+      } else {
+        roleSwitch = true;
+      }
+    } else {
+      ALOGI("Role switch failed while wrting to file");
+    }
+    pthread_mutex_unlock(&usb->mPartnerLock);
+  }
+
+  if (!roleSwitch)
+    switchToDrp(std::string(portName.c_str()));
+
+  return roleSwitch;
+}
+
+Usb::Usb()
+        : mLock(PTHREAD_MUTEX_INITIALIZER),
+          mRoleSwitchLock(PTHREAD_MUTEX_INITIALIZER),
+          mPartnerLock(PTHREAD_MUTEX_INITIALIZER),
+          mPartnerUp(false) {
+    pthread_condattr_t attr;
+    if (pthread_condattr_init(&attr)) {
+        ALOGE("pthread_condattr_init failed: %s", strerror(errno));
+        abort();
+    }
+    if (pthread_condattr_setclock(&attr, CLOCK_MONOTONIC)) {
+        ALOGE("pthread_condattr_setclock failed: %s", strerror(errno));
+        abort();
+    }
+    if (pthread_cond_init(&mPartnerCV, &attr))  {
+        ALOGE("pthread_cond_init failed: %s", strerror(errno));
+        abort();
+    }
+    if (pthread_condattr_destroy(&attr)) {
+        ALOGE("pthread_condattr_destroy failed: %s", strerror(errno));
+        abort();
+    }
+}
+
+
+Return<void> Usb::switchRole(const hidl_string &portName,
+                             const V1_0::PortRole &newRole) {
+  std::string filename =
+      appendRoleNodeHelper(std::string(portName.c_str()), newRole.type);
+  std::string written;
+  FILE *fp;
+  bool roleSwitch = false;
+
+  if (filename == "") {
+    ALOGE("Fatal: invalid node type");
     return Void();
+  }
+
+  pthread_mutex_lock(&mRoleSwitchLock);
+
+  ALOGI("filename write: %s role:%s", filename.c_str(),
+        convertRoletoString(newRole).c_str());
+
+  if (newRole.type == PortRoleType::MODE) {
+      roleSwitch = switchMode(portName, newRole, this);
+  } else {
+    fp = fopen(filename.c_str(), "w");
+    if (fp != NULL) {
+      int ret = fputs(convertRoletoString(newRole).c_str(), fp);
+      fclose(fp);
+      if ((ret != EOF) && !readFile(filename, &written)) {
+        extractRole(&written);
+        ALOGI("written: %s", written.c_str());
+        if (written == convertRoletoString(newRole)) {
+          roleSwitch = true;
+        } else {
+          ALOGE("Role switch failed");
+        }
+      } else {
+        ALOGE("failed to update the new role");
+      }
+    } else {
+      ALOGE("fopen failed");
+    }
+  }
+
+  pthread_mutex_lock(&mLock);
+  if (mCallback_1_0 != NULL) {
+    Return<void> ret =
+        mCallback_1_0->notifyRoleSwitchStatus(portName, newRole,
+        roleSwitch ? Status::SUCCESS : Status::ERROR);
+    if (!ret.isOk())
+      ALOGE("RoleSwitchStatus error %s", ret.description().c_str());
+  } else {
+    ALOGE("Not notifying the userspace. Callback is not set");
+  }
+  pthread_mutex_unlock(&mLock);
+  pthread_mutex_unlock(&mRoleSwitchLock);
+
+  return Void();
 }
 
-Return<void> Usb::queryPortStatus() {
-    hidl_vec<PortStatus> currentPortStatus;
-    currentPortStatus.resize(1);
-
-    currentPortStatus[0].portName = "otg_default";
-    currentPortStatus[0].currentDataRole = PortDataRole::DEVICE;
-    currentPortStatus[0].currentPowerRole = PortPowerRole::SINK;
-    currentPortStatus[0].currentMode = PortMode::UFP;
-    currentPortStatus[0].canChangeMode = false;
-    currentPortStatus[0].canChangeDataRole = false;
-    currentPortStatus[0].canChangePowerRole = false;
-    currentPortStatus[0].supportedModes = PortMode::UFP;
-
-    pthread_mutex_lock(&mLock);
-    if (mCallback != NULL) {
-        Return<void> ret =
-                mCallback->notifyPortStatusChange(currentPortStatus, Status::SUCCESS);
-        if (!ret.isOk()) {
-            LOG(ERROR) << "queryPortStatus error " << ret.description();
+Status getAccessoryConnected(const std::string &portName, std::string *accessory) {
+  std::string filename =
+    "/sys/class/typec/" + portName + "-partner/accessory_mode";
+
+  if (readFile(filename, accessory)) {
+    ALOGE("getAccessoryConnected: Failed to open filesystem node: %s",
+          filename.c_str());
+    return Status::ERROR;
+  }
+
+  return Status::SUCCESS;
+}
+
+Status getCurrentRoleHelper(const std::string &portName, bool connected,
+                            PortRoleType type, uint32_t *currentRole) {
+  std::string filename;
+  std::string roleName;
+  std::string accessory;
+
+  // Mode
+
+  if (type == PortRoleType::POWER_ROLE) {
+    filename = "/sys/class/typec/" + portName + "/power_role";
+    *currentRole = static_cast<uint32_t>(PortPowerRole::NONE);
+  } else if (type == PortRoleType::DATA_ROLE) {
+    filename = "/sys/class/typec/" + portName + "/data_role";
+    *currentRole = static_cast<uint32_t>(PortDataRole::NONE);
+  } else if (type == PortRoleType::MODE) {
+    filename = "/sys/class/typec/" + portName + "/data_role";
+    *currentRole = static_cast<uint32_t>(PortMode_1_1::NONE);
+  } else {
+    return Status::ERROR;
+  }
+
+  if (!connected) return Status::SUCCESS;
+
+  if (type == PortRoleType::MODE) {
+    if (getAccessoryConnected(portName, &accessory) != Status::SUCCESS) {
+      return Status::ERROR;
+    }
+    if (accessory == "analog_audio") {
+      *currentRole = static_cast<uint32_t>(PortMode_1_1::AUDIO_ACCESSORY);
+      return Status::SUCCESS;
+    } else if (accessory == "debug") {
+      *currentRole = static_cast<uint32_t>(PortMode_1_1::DEBUG_ACCESSORY);
+      return Status::SUCCESS;
+    }
+  }
+
+  if (readFile(filename, &roleName)) {
+    ALOGE("getCurrentRole: Failed to open filesystem node: %s",
+          filename.c_str());
+    return Status::ERROR;
+  }
+
+  extractRole(&roleName);
+
+  if (roleName == "source") {
+    *currentRole = static_cast<uint32_t>(PortPowerRole::SOURCE);
+  } else if (roleName == "sink") {
+    *currentRole = static_cast<uint32_t>(PortPowerRole::SINK);
+  } else if (roleName == "host") {
+    if (type == PortRoleType::DATA_ROLE)
+      *currentRole = static_cast<uint32_t>(PortDataRole::HOST);
+    else
+      *currentRole = static_cast<uint32_t>(PortMode_1_1::DFP);
+  } else if (roleName == "device") {
+    if (type == PortRoleType::DATA_ROLE)
+      *currentRole = static_cast<uint32_t>(PortDataRole::DEVICE);
+    else
+      *currentRole = static_cast<uint32_t>(PortMode_1_1::UFP);
+  } else if (roleName != "none") {
+    /* case for none has already been addressed.
+     * so we check if the role isnt none.
+     */
+    return Status::UNRECOGNIZED_ROLE;
+  }
+
+  return Status::SUCCESS;
+}
+
+Status getTypeCPortNamesHelper(std::unordered_map<std::string, bool> *names) {
+  DIR *dp;
+
+  dp = opendir("/sys/class/typec");
+  if (dp != NULL) {
+    struct dirent *ep;
+
+    while ((ep = readdir(dp))) {
+      if (ep->d_type == DT_LNK) {
+        if (std::string::npos == std::string(ep->d_name).find("-partner")) {
+          std::unordered_map<std::string, bool>::const_iterator portName =
+              names->find(ep->d_name);
+          if (portName == names->end()) {
+            names->insert({ep->d_name, false});
+          }
+        } else {
+          (*names)[std::strtok(ep->d_name, "-")] = true;
         }
+      }
+    }
+    closedir(dp);
+    return Status::SUCCESS;
+  }
+
+  ALOGE("Failed to open /sys/class/typec");
+  return Status::ERROR;
+}
+
+bool canSwitchRoleHelper(const std::string &portName, PortRoleType /*type*/) {
+  std::string filename =
+      "/sys/class/typec/" + portName + "-partner/supports_usb_power_delivery";
+  std::string supportsPD;
+
+  if (!readFile(filename, &supportsPD)) {
+    if (supportsPD == "yes") {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+/*
+ * Reuse the same method for both V1_0 and V1_1 callback objects.
+ * The caller of this method would reconstruct the V1_0::PortStatus
+ * object if required.
+ */
+Status getPortStatusHelper(hidl_vec<PortStatus_1_1> *currentPortStatus_1_1,
+    bool V1_0) {
+  std::unordered_map<std::string, bool> names;
+  Status result = getTypeCPortNamesHelper(&names);
+  int i = -1;
+
+  if (result == Status::SUCCESS) {
+    currentPortStatus_1_1->resize(names.size());
+    for (std::pair<std::string, bool> port : names) {
+      i++;
+      ALOGI("%s", port.first.c_str());
+      (*currentPortStatus_1_1)[i].status.portName = port.first;
+
+      uint32_t currentRole;
+      if (getCurrentRoleHelper(port.first, port.second,
+                               PortRoleType::POWER_ROLE,
+                               &currentRole) == Status::SUCCESS) {
+        (*currentPortStatus_1_1)[i].status.currentPowerRole =
+            static_cast<PortPowerRole>(currentRole);
+      } else {
+        ALOGE("Error while retreiving portNames");
+        goto done;
+      }
+
+      if (getCurrentRoleHelper(port.first, port.second, PortRoleType::DATA_ROLE,
+                               &currentRole) == Status::SUCCESS) {
+        (*currentPortStatus_1_1)[i].status.currentDataRole =
+            static_cast<PortDataRole>(currentRole);
+      } else {
+        ALOGE("Error while retreiving current port role");
+        goto done;
+      }
+
+      if (getCurrentRoleHelper(port.first, port.second, PortRoleType::MODE,
+                               &currentRole) == Status::SUCCESS) {
+        (*currentPortStatus_1_1)[i].currentMode =
+            static_cast<PortMode_1_1>(currentRole);
+        (*currentPortStatus_1_1)[i].status.currentMode =
+            static_cast<V1_0::PortMode>(currentRole);
+      } else {
+        ALOGE("Error while retreiving current data role");
+        goto done;
+      }
+
+      (*currentPortStatus_1_1)[i].status.canChangeMode = true;
+      (*currentPortStatus_1_1)[i].status.canChangeDataRole =
+          port.second ? canSwitchRoleHelper(port.first, PortRoleType::DATA_ROLE)
+                      : false;
+      (*currentPortStatus_1_1)[i].status.canChangePowerRole =
+          port.second
+              ? canSwitchRoleHelper(port.first, PortRoleType::POWER_ROLE)
+              : false;
+
+      ALOGI("connected:%d canChangeMode:%d canChagedata:%d canChangePower:%d",
+            port.second, (*currentPortStatus_1_1)[i].status.canChangeMode,
+            (*currentPortStatus_1_1)[i].status.canChangeDataRole,
+            (*currentPortStatus_1_1)[i].status.canChangePowerRole);
+
+      if (V1_0) {
+        (*currentPortStatus_1_1)[i].status.supportedModes = V1_0::PortMode::DFP;
+      } else {
+        (*currentPortStatus_1_1)[i].supportedModes = PortMode_1_1::UFP | PortMode_1_1::DFP;
+        (*currentPortStatus_1_1)[i].status.supportedModes = V1_0::PortMode::NONE;
+        (*currentPortStatus_1_1)[i].status.currentMode = V1_0::PortMode::NONE;
+      }
+    }
+    return Status::SUCCESS;
+  }
+done:
+  return Status::ERROR;
+}
+
+Return<void> Usb::queryPortStatus() {
+  hidl_vec<PortStatus_1_1> currentPortStatus_1_1;
+  hidl_vec<V1_0::PortStatus> currentPortStatus;
+  Status status;
+  sp<IUsbCallback> callback_V1_1 = IUsbCallback::castFrom(mCallback_1_0);
+
+  pthread_mutex_lock(&mLock);
+  if (mCallback_1_0 != NULL) {
+    if (callback_V1_1 != NULL) {
+      status = getPortStatusHelper(&currentPortStatus_1_1, false);
     } else {
-        LOG(INFO) << "Notifying userspace skipped. Callback is NULL";
+      status = getPortStatusHelper(&currentPortStatus_1_1, true);
+      currentPortStatus.resize(currentPortStatus_1_1.size());
+      for (unsigned long i = 0; i < currentPortStatus_1_1.size(); i++)
+        currentPortStatus[i] = currentPortStatus_1_1[i].status;
     }
-    pthread_mutex_unlock(&mLock);
 
-    return Void();
+    Return<void> ret;
+
+    if (callback_V1_1 != NULL)
+      ret = callback_V1_1->notifyPortStatusChange_1_1(currentPortStatus_1_1, status);
+    else
+      ret = mCallback_1_0->notifyPortStatusChange(currentPortStatus, status);
+
+    if (!ret.isOk())
+      ALOGE("queryPortStatus_1_1 error %s", ret.description().c_str());
+  } else {
+    ALOGI("Notifying userspace skipped. Callback is NULL");
+  }
+  pthread_mutex_unlock(&mLock);
+
+  return Void();
+}
+
+struct data {
+  int uevent_fd;
+  android::hardware::usb::V1_1::implementation::Usb *usb;
+};
+
+static void uevent_event(uint32_t /*epevents*/, struct data *payload) {
+  char msg[UEVENT_MSG_LEN + 2];
+  char *cp;
+  int n;
+
+  n = uevent_kernel_multicast_recv(payload->uevent_fd, msg, UEVENT_MSG_LEN);
+  if (n <= 0) return;
+  if (n >= UEVENT_MSG_LEN) /* overflow -- discard */
+    return;
+
+  msg[n] = '\0';
+  msg[n + 1] = '\0';
+  cp = msg;
+
+  while (*cp) {
+    if (std::regex_match(cp, std::regex("(add)(.*)(-partner)"))) {
+       ALOGI("partner added");
+       pthread_mutex_lock(&payload->usb->mPartnerLock);
+       payload->usb->mPartnerUp = true;
+       pthread_cond_signal(&payload->usb->mPartnerCV);
+       pthread_mutex_unlock(&payload->usb->mPartnerLock);
+    } else if (!strncmp(cp, "DEVTYPE=typec_", strlen("DEVTYPE=typec_"))) {
+      hidl_vec<PortStatus_1_1> currentPortStatus_1_1;
+      ALOGI("uevent received %s", cp);
+      pthread_mutex_lock(&payload->usb->mLock);
+      if (payload->usb->mCallback_1_0 != NULL) {
+        sp<IUsbCallback> callback_V1_1 = IUsbCallback::castFrom(payload->usb->mCallback_1_0);
+        Return<void> ret;
+
+        // V1_1 callback
+        if (callback_V1_1 != NULL) {
+          Status status = getPortStatusHelper(&currentPortStatus_1_1, false);
+          ret = callback_V1_1->notifyPortStatusChange_1_1(
+              currentPortStatus_1_1, status);
+        } else { // V1_0 callback
+          Status status = getPortStatusHelper(&currentPortStatus_1_1, true);
+
+          /*
+           * Copying the result from getPortStatusHelper
+           * into V1_0::PortStatus to pass back through
+           * the V1_0 callback object.
+           */
+          hidl_vec<V1_0::PortStatus> currentPortStatus;
+          currentPortStatus.resize(currentPortStatus_1_1.size());
+          for (unsigned long i = 0; i < currentPortStatus_1_1.size(); i++)
+            currentPortStatus[i] = currentPortStatus_1_1[i].status;
+
+          ret = payload->usb->mCallback_1_0->notifyPortStatusChange(
+              currentPortStatus, status);
+        }
+        if (!ret.isOk()) ALOGE("error %s", ret.description().c_str());
+      } else {
+        ALOGI("Notifying userspace skipped. Callback is NULL");
+      }
+      pthread_mutex_unlock(&payload->usb->mLock);
+
+      //Role switch is not in progress and port is in disconnected state
+      if (!pthread_mutex_trylock(&payload->usb->mRoleSwitchLock)) {
+        for (unsigned long i = 0; i < currentPortStatus_1_1.size(); i++) {
+          DIR *dp = opendir(std::string("/sys/class/typec/"
+              + std::string(currentPortStatus_1_1[i].status.portName.c_str())
+              + "-partner").c_str());
+          if (dp == NULL) {
+              //PortRole role = {.role = static_cast<uint32_t>(PortMode::UFP)};
+              switchToDrp(currentPortStatus_1_1[i].status.portName);
+          } else {
+              closedir(dp);
+          }
+        }
+        pthread_mutex_unlock(&payload->usb->mRoleSwitchLock);
+      }
+      break;
+    }
+    /* advance to after the next \0 */
+    while (*cp++) {}
+  }
 }
 
-Return<void> Usb::setCallback(const sp<IUsbCallback> &callback) {
-    pthread_mutex_lock(&mLock);
+void *work(void *param) {
+  int epoll_fd, uevent_fd;
+  struct epoll_event ev;
+  int nevents = 0;
+  struct data payload;
+
+  ALOGE("creating thread");
+
+  uevent_fd = uevent_open_socket(64 * 1024, true);
+
+  if (uevent_fd < 0) {
+    ALOGE("uevent_init: uevent_open_socket failed\n");
+    return NULL;
+  }
 
-    mCallback = callback;
-    LOG(INFO) << "registering callback";
+  payload.uevent_fd = uevent_fd;
+  payload.usb = (android::hardware::usb::V1_1::implementation::Usb *)param;
+
+  fcntl(uevent_fd, F_SETFL, O_NONBLOCK);
+
+  ev.events = EPOLLIN;
+  ev.data.ptr = (void *)uevent_event;
+
+  epoll_fd = epoll_create(64);
+  if (epoll_fd == -1) {
+    ALOGE("epoll_create failed; errno=%d", errno);
+    goto error;
+  }
+
+  if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, uevent_fd, &ev) == -1) {
+    ALOGE("epoll_ctl failed; errno=%d", errno);
+    goto error;
+  }
+
+  while (!destroyThread) {
+    struct epoll_event events[64];
+
+    nevents = epoll_wait(epoll_fd, events, 64, -1);
+    if (nevents == -1) {
+      if (errno == EINTR) continue;
+      ALOGE("usb epoll_wait failed; errno=%d", errno);
+      break;
+    }
+
+    for (int n = 0; n < nevents; ++n) {
+      if (events[n].data.ptr)
+        (*(void (*)(int, struct data *payload))events[n].data.ptr)(
+            events[n].events, &payload);
+    }
+  }
 
+  ALOGI("exiting worker thread");
+error:
+  close(uevent_fd);
+
+  if (epoll_fd >= 0) close(epoll_fd);
+
+  return NULL;
+}
+
+void sighandler(int sig) {
+  if (sig == SIGUSR1) {
+    destroyThread = true;
+    ALOGI("destroy set");
+    return;
+  }
+  signal(SIGUSR1, sighandler);
+}
+
+Return<void> Usb::setCallback(const sp<V1_0::IUsbCallback> &callback) {
+
+  sp<IUsbCallback> callback_V1_1 = IUsbCallback::castFrom(callback);
+
+  if (callback != NULL)
+      if (callback_V1_1 == NULL)
+          ALOGI("Registering 1.0 callback");
+
+  pthread_mutex_lock(&mLock);
+  /*
+   * When both the old callback and new callback values are NULL,
+   * there is no need to spin off the worker thread.
+   * When both the values are not NULL, we would already have a
+   * worker thread running, so updating the callback object would
+   * be suffice.
+   */
+  if ((mCallback_1_0 == NULL && callback == NULL) ||
+      (mCallback_1_0 != NULL && callback != NULL)) {
+    /*
+     * Always store as V1_0 callback object. Type cast to V1_1
+     * when the callback is actually invoked.
+     */
+    mCallback_1_0 = callback;
     pthread_mutex_unlock(&mLock);
     return Void();
+  }
+
+  mCallback_1_0 = callback;
+  ALOGI("registering callback");
+
+  // Kill the worker thread if the new callback is NULL.
+  if (mCallback_1_0 == NULL) {
+    pthread_mutex_unlock(&mLock);
+    if (!pthread_kill(mPoll, SIGUSR1)) {
+      pthread_join(mPoll, NULL);
+      ALOGI("pthread destroyed");
+    }
+    return Void();
+  }
+
+  destroyThread = false;
+  signal(SIGUSR1, sighandler);
+
+  /*
+   * Create a background thread if the old callback value is NULL
+   * and being updated with a new value.
+   */
+  if (pthread_create(&mPoll, NULL, work, this)) {
+    ALOGE("pthread creation failed %d", errno);
+    mCallback_1_0 = NULL;
+  }
+
+  pthread_mutex_unlock(&mLock);
+  return Void();
 }
 
 }  // namespace implementation
diff --git a/usb/Usb.h b/usb/Usb.h
index 364da81..09bfdf9 100644
--- a/usb/Usb.h
+++ b/usb/Usb.h
@@ -1,27 +1,35 @@
-#ifndef ANDROID_HARDWARE_USB_V1_0_USB_H
-#define ANDROID_HARDWARE_USB_V1_0_USB_H
+#ifndef ANDROID_HARDWARE_USB_V1_1_USB_H
+#define ANDROID_HARDWARE_USB_V1_1_USB_H
 
-#include <android/hardware/usb/1.0/IUsb.h>
-#include <hidl/MQDescriptor.h>
+#include <android/hardware/usb/1.1/IUsb.h>
+#include <android/hardware/usb/1.1/types.h>
+#include <android/hardware/usb/1.1/IUsbCallback.h>
 #include <hidl/Status.h>
 #include <utils/Log.h>
 
-#ifdef LOG_TAG
-#undef LOG_TAG
-#endif
-
-#define LOG_TAG "android.hardware.usb@1.0-service.xiaomi_sdm660"
 #define UEVENT_MSG_LEN 2048
+// The type-c stack waits for 4.5 - 5.5 secs before declaring a port non-pd.
+// The -partner directory would not be created until this is done.
+// Having a margin of ~3 secs for the directory and other related bookeeping
+// structures created and uvent fired.
+#define PORT_TYPE_TIMEOUT 8
 
 namespace android {
 namespace hardware {
 namespace usb {
-namespace V1_0 {
+namespace V1_1 {
 namespace implementation {
 
-using ::android::hardware::usb::V1_0::IUsb;
-using ::android::hardware::usb::V1_0::IUsbCallback;
 using ::android::hardware::usb::V1_0::PortRole;
+using ::android::hardware::usb::V1_0::PortRoleType;
+using ::android::hardware::usb::V1_0::PortDataRole;
+using ::android::hardware::usb::V1_0::PortPowerRole;
+using ::android::hardware::usb::V1_0::Status;
+using ::android::hardware::usb::V1_1::IUsb;
+using ::android::hardware::usb::V1_1::IUsbCallback;
+using ::android::hardware::usb::V1_1::PortMode_1_1;
+using ::android::hardware::usb::V1_1::PortStatus_1_1;
+using ::android::hidl::base::V1_0::DebugInfo;
 using ::android::hidl::base::V1_0::IBase;
 using ::android::hardware::hidl_array;
 using ::android::hardware::hidl_memory;
@@ -32,12 +40,27 @@ using ::android::hardware::Void;
 using ::android::sp;
 
 struct Usb : public IUsb {
-    Return<void> switchRole(const hidl_string& portName, const PortRole& role) override;
-    Return<void> setCallback(const sp<IUsbCallback>& callback) override;
+    Usb();
+
+    Return<void> switchRole(const hidl_string& portName, const V1_0::PortRole& role) override;
+    Return<void> setCallback(const sp<V1_0::IUsbCallback>& callback) override;
     Return<void> queryPortStatus() override;
 
-    sp<IUsbCallback> mCallback;
-    pthread_mutex_t mLock = PTHREAD_MUTEX_INITIALIZER;
+
+    sp<V1_0::IUsbCallback> mCallback_1_0;
+    // Protects mCallback variable
+    pthread_mutex_t mLock;
+    // Protects roleSwitch operation
+    pthread_mutex_t mRoleSwitchLock;
+    // Threads waiting for the partner to come back wait here
+    pthread_cond_t mPartnerCV;
+    // lock protecting mPartnerCV
+    pthread_mutex_t mPartnerLock;
+    // Variable to signal partner coming back online after type switch
+    bool mPartnerUp;
+
+    private:
+        pthread_t mPoll;
 };
 
 }  // namespace implementation
@@ -46,4 +69,4 @@ struct Usb : public IUsb {
 }  // namespace hardware
 }  // namespace android
 
-#endif  // ANDROID_HARDWARE_USB_V1_0_USB_H
+#endif  // ANDROID_HARDWARE_USB_V1_1_USB_H
diff --git a/usb/UsbGadget.cpp b/usb/UsbGadget.cpp
new file mode 100644
index 0000000..cdcbc5b
--- /dev/null
+++ b/usb/UsbGadget.cpp
@@ -0,0 +1,650 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "android.hardware.usb.gadget@1.0-service.xiaomi_sdm660"
+
+#include "UsbGadget.h"
+#include <dirent.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <sys/inotify.h>
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+constexpr int BUFFER_SIZE = 512;
+constexpr int MAX_FILE_PATH_LENGTH = 256;
+constexpr int EPOLL_EVENTS = 10;
+constexpr bool DEBUG = false;
+constexpr int DISCONNECT_WAIT_US = 100000;
+constexpr int PULL_UP_DELAY = 500000;
+
+#define BUILD_TYPE "ro.build.type"
+#define GADGET_PATH "/config/usb_gadget/g1/"
+#define PULLUP_PATH GADGET_PATH "UDC"
+#define GADGET_NAME "a600000.dwc3"
+#define PERSISTENT_BOOT_MODE "ro.bootmode"
+#define VENDOR_ID_PATH GADGET_PATH "idVendor"
+#define PRODUCT_ID_PATH GADGET_PATH "idProduct"
+#define DEVICE_CLASS_PATH GADGET_PATH "bDeviceClass"
+#define DEVICE_SUB_CLASS_PATH GADGET_PATH "bDeviceSubClass"
+#define DEVICE_PROTOCOL_PATH GADGET_PATH "bDeviceProtocol"
+#define DESC_USE_PATH GADGET_PATH "os_desc/use"
+#define OS_DESC_PATH GADGET_PATH "os_desc/b.1"
+#define CONFIG_PATH GADGET_PATH "configs/b.1/"
+#define FUNCTIONS_PATH GADGET_PATH "functions/"
+#define FUNCTION_NAME "function"
+#define FUNCTION_PATH CONFIG_PATH FUNCTION_NAME
+#define RNDIS_PATH FUNCTIONS_PATH "gsi.rndis"
+
+#define PERSISTENT_VENDOR_CONFIG "persist.vendor.usb.usbradio.config"
+#define VENDOR_CONFIG "vendor.usb.config"
+
+namespace android {
+namespace hardware {
+namespace usb {
+namespace gadget {
+namespace V1_0 {
+namespace implementation {
+
+volatile bool gadgetPullup;
+
+// Used for debug.
+static void displayInotifyEvent(struct inotify_event *i) {
+  ALOGE("    wd =%2d; ", i->wd);
+  if (i->cookie > 0) ALOGE("cookie =%4d; ", i->cookie);
+
+  ALOGE("mask = ");
+  if (i->mask & IN_ACCESS) ALOGE("IN_ACCESS ");
+  if (i->mask & IN_ATTRIB) ALOGE("IN_ATTRIB ");
+  if (i->mask & IN_CLOSE_NOWRITE) ALOGE("IN_CLOSE_NOWRITE ");
+  if (i->mask & IN_CLOSE_WRITE) ALOGE("IN_CLOSE_WRITE ");
+  if (i->mask & IN_CREATE) ALOGE("IN_CREATE ");
+  if (i->mask & IN_DELETE) ALOGE("IN_DELETE ");
+  if (i->mask & IN_DELETE_SELF) ALOGE("IN_DELETE_SELF ");
+  if (i->mask & IN_IGNORED) ALOGE("IN_IGNORED ");
+  if (i->mask & IN_ISDIR) ALOGE("IN_ISDIR ");
+  if (i->mask & IN_MODIFY) ALOGE("IN_MODIFY ");
+  if (i->mask & IN_MOVE_SELF) ALOGE("IN_MOVE_SELF ");
+  if (i->mask & IN_MOVED_FROM) ALOGE("IN_MOVED_FROM ");
+  if (i->mask & IN_MOVED_TO) ALOGE("IN_MOVED_TO ");
+  if (i->mask & IN_OPEN) ALOGE("IN_OPEN ");
+  if (i->mask & IN_Q_OVERFLOW) ALOGE("IN_Q_OVERFLOW ");
+  if (i->mask & IN_UNMOUNT) ALOGE("IN_UNMOUNT ");
+  ALOGE("\n");
+
+  if (i->len > 0) ALOGE("        name = %s\n", i->name);
+}
+
+static void *monitorFfs(void *param) {
+  UsbGadget *usbGadget = (UsbGadget *)param;
+  char buf[BUFFER_SIZE];
+  bool writeUdc = true, stopMonitor = false;
+  struct epoll_event events[EPOLL_EVENTS];
+  steady_clock::time_point disconnect;
+
+  bool descriptorWritten = true;
+  for (int i = 0; i < static_cast<int>(usbGadget->mEndpointList.size()); i++) {
+    if (access(usbGadget->mEndpointList.at(i).c_str(), R_OK)) {
+      descriptorWritten = false;
+      break;
+    }
+  }
+
+  // notify here if the endpoints are already present.
+  if (descriptorWritten) {
+    usleep(PULL_UP_DELAY);
+    if (!!WriteStringToFile(GADGET_NAME, PULLUP_PATH)) {
+      lock_guard<mutex> lock(usbGadget->mLock);
+      usbGadget->mCurrentUsbFunctionsApplied = true;
+      gadgetPullup = true;
+      writeUdc = false;
+      ALOGI("GADGET pulled up");
+      usbGadget->mCv.notify_all();
+    }
+  }
+
+  while (!stopMonitor) {
+    int nrEvents = epoll_wait(usbGadget->mEpollFd, events, EPOLL_EVENTS, -1);
+
+    if (nrEvents <= 0) {
+      ALOGE("epoll wait did not return descriptor number");
+      continue;
+    }
+
+    for (int i = 0; i < nrEvents; i++) {
+      ALOGI("event=%u on fd=%d\n", events[i].events, events[i].data.fd);
+
+      if (events[i].data.fd == usbGadget->mInotifyFd) {
+        // Process all of the events in buffer returned by read().
+        int numRead = read(usbGadget->mInotifyFd, buf, BUFFER_SIZE);
+        for (char *p = buf; p < buf + numRead;) {
+          struct inotify_event *event = (struct inotify_event *)p;
+          if (DEBUG) displayInotifyEvent(event);
+
+          p += sizeof(struct inotify_event) + event->len;
+
+          bool descriptorPresent = true;
+          for (int j = 0; j < static_cast<int>(usbGadget->mEndpointList.size());
+               j++) {
+            if (access(usbGadget->mEndpointList.at(j).c_str(), R_OK)) {
+              if (DEBUG)
+                ALOGI("%s absent", usbGadget->mEndpointList.at(j).c_str());
+              descriptorPresent = false;
+              break;
+            }
+          }
+
+          if (!descriptorPresent && !writeUdc) {
+            if (DEBUG) ALOGI("endpoints not up");
+            writeUdc = true;
+            disconnect = std::chrono::steady_clock::now();
+          } else if (descriptorPresent && writeUdc) {
+            steady_clock::time_point temp = steady_clock::now();
+
+            if (std::chrono::duration_cast<microseconds>(temp - disconnect).count()
+                < PULL_UP_DELAY)
+              usleep(PULL_UP_DELAY);
+
+            if(!!WriteStringToFile(GADGET_NAME, PULLUP_PATH)) {
+              lock_guard<mutex> lock(usbGadget->mLock);
+              usbGadget->mCurrentUsbFunctionsApplied = true;
+              ALOGI("GADGET pulled up");
+              writeUdc = false;
+              gadgetPullup = true;
+              // notify the main thread to signal userspace.
+              usbGadget->mCv.notify_all();
+            }
+          }
+        }
+      } else {
+        uint64_t flag;
+        read(usbGadget->mEventFd, &flag, sizeof(flag));
+        if (flag == 100) {
+          stopMonitor = true;
+          break;
+        }
+      }
+    }
+  }
+  return NULL;
+}
+
+UsbGadget::UsbGadget()
+    : mMonitorCreated(false), mCurrentUsbFunctionsApplied(false) {
+  if (access(OS_DESC_PATH, R_OK) != 0) ALOGE("configfs setup not done yet");
+}
+
+static int unlinkFunctions(const char *path) {
+  DIR *config = opendir(path);
+  struct dirent *function;
+  char filepath[MAX_FILE_PATH_LENGTH];
+  int ret = 0;
+
+  if (config == NULL) return -1;
+
+  // d_type does not seems to be supported in /config
+  // so filtering by name.
+  while (((function = readdir(config)) != NULL)) {
+    if ((strstr(function->d_name, FUNCTION_NAME) == NULL)) continue;
+    // build the path for each file in the folder.
+    sprintf(filepath, "%s/%s", path, function->d_name);
+    ret = remove(filepath);
+    if (ret) {
+      ALOGE("Unable  remove file %s errno:%d", filepath, errno);
+      break;
+    }
+  }
+
+  closedir(config);
+  return ret;
+}
+
+static int addEpollFd(const unique_fd &epfd, const unique_fd &fd) {
+  struct epoll_event event;
+  int ret;
+
+  event.data.fd = fd;
+  event.events = EPOLLIN;
+
+  ret = epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event);
+  if (ret) ALOGE("epoll_ctl error %d", errno);
+
+  return ret;
+}
+
+Return<void> UsbGadget::getCurrentUsbFunctions(
+    const sp<V1_0::IUsbGadgetCallback> &callback) {
+  Return<void> ret = callback->getCurrentUsbFunctionsCb(
+      mCurrentUsbFunctions, mCurrentUsbFunctionsApplied
+                                ? Status::FUNCTIONS_APPLIED
+                                : Status::FUNCTIONS_NOT_APPLIED);
+  if (!ret.isOk())
+    ALOGE("Call to getCurrentUsbFunctionsCb failed %s",
+          ret.description().c_str());
+
+  return Void();
+}
+
+V1_0::Status UsbGadget::tearDownGadget() {
+  ALOGI("setCurrentUsbFunctions None");
+
+  if (!WriteStringToFile("none", PULLUP_PATH))
+    ALOGI("Gadget cannot be pulled down");
+
+  if (!WriteStringToFile("0", DEVICE_CLASS_PATH)) return Status::ERROR;
+
+  if (!WriteStringToFile("0", DEVICE_SUB_CLASS_PATH)) return Status::ERROR;
+
+  if (!WriteStringToFile("0", DEVICE_PROTOCOL_PATH)) return Status::ERROR;
+
+  if (!WriteStringToFile("0", DESC_USE_PATH)) return Status::ERROR;
+
+  if (unlinkFunctions(CONFIG_PATH)) return Status::ERROR;
+
+  if (mMonitorCreated) {
+    uint64_t flag = 100;
+    unsigned long ret;
+
+    // Stop the monitor thread by writing into signal fd.
+    ret = TEMP_FAILURE_RETRY(write(mEventFd, &flag, sizeof(flag)));
+    if (ret < 0) {
+        ALOGE("Error writing errno=%d", errno);
+    } else if (ret < sizeof(flag)) {
+        ALOGE("Short write length=%zd", ret);
+    }
+
+    ALOGI("mMonitor signalled to exit");
+    mMonitor->join();
+    mMonitorCreated = false;
+    ALOGI("mMonitor destroyed");
+  } else {
+    ALOGI("mMonitor not running");
+  }
+
+  mInotifyFd.reset(-1);
+  mEventFd.reset(-1);
+  mEpollFd.reset(-1);
+  mEndpointList.clear();
+  return Status::SUCCESS;
+}
+
+static int linkFunction(const char *function, int index) {
+  char functionPath[MAX_FILE_PATH_LENGTH];
+  char link[MAX_FILE_PATH_LENGTH];
+
+  sprintf(functionPath, "%s%s", FUNCTIONS_PATH, function);
+  sprintf(link, "%s%d", FUNCTION_PATH, index);
+  if (symlink(functionPath, link)) {
+    ALOGE("Cannot create symlink %s -> %s errno:%d", link, functionPath, errno);
+    return -1;
+  }
+  return 0;
+}
+
+static V1_0::Status setVidPid(const char *vid, const char *pid) {
+  if (!WriteStringToFile(vid, VENDOR_ID_PATH)) return Status::ERROR;
+
+  if (!WriteStringToFile(pid, PRODUCT_ID_PATH)) return Status::ERROR;
+
+  return Status::SUCCESS;
+}
+
+static std::string getVendorFunctions() {
+  if (GetProperty(BUILD_TYPE, "") == "user") return "user";
+
+  std::string bootMode = GetProperty(PERSISTENT_BOOT_MODE, "");
+  std::string persistVendorFunctions =
+      GetProperty(PERSISTENT_VENDOR_CONFIG, "");
+  std::string vendorFunctions = GetProperty(VENDOR_CONFIG, "");
+  std::string ret = "";
+
+  if (vendorFunctions != "") {
+    ret = vendorFunctions;
+  } else if (bootMode == "usbradio") {
+    if (persistVendorFunctions != "")
+      ret = persistVendorFunctions;
+    else
+      ret = "diag";
+    // vendor.usb.config will reflect the current configured functions
+    SetProperty(VENDOR_CONFIG, ret);
+  }
+
+  return ret;
+}
+
+static V1_0::Status validateAndSetVidPid(uint64_t functions) {
+  V1_0::Status ret = Status::SUCCESS;
+  std::string vendorFunctions = getVendorFunctions();
+
+  switch (functions) {
+    case static_cast<uint64_t>(GadgetFunction::MTP):
+      if (vendorFunctions == "diag") {
+        ret = setVidPid("0x05C6", "0x901B");
+      } else {
+        if (!(vendorFunctions == "user" || vendorFunctions == ""))
+          ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+        ret = setVidPid("0x18d1", "0x4ee1");
+      }
+      break;
+    case GadgetFunction::ADB | GadgetFunction::MTP:
+      if (vendorFunctions == "diag") {
+        ret = setVidPid("0x05C6", "0x903A");
+      } else {
+        if (!(vendorFunctions == "user" || vendorFunctions == ""))
+          ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+        ret = setVidPid("0x18d1", "0x4ee2");
+      }
+      break;
+    case static_cast<uint64_t>(GadgetFunction::RNDIS):
+      if (vendorFunctions == "diag") {
+        ret = setVidPid("0x05C6", "0x902C");
+      } else if (vendorFunctions == "serial_cdev,diag") {
+        ret = setVidPid("0x05C6", "0x90B5");
+      } else {
+        if (!(vendorFunctions == "user" || vendorFunctions == ""))
+          ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+        ret = setVidPid("0x18d1", "0x4ee3");
+      }
+      break;
+    case GadgetFunction::ADB | GadgetFunction::RNDIS:
+      if (vendorFunctions == "diag") {
+        ret = setVidPid("0x05C6", "0x902D");
+      } else if (vendorFunctions == "serial_cdev,diag") {
+        ret = setVidPid("0x05C6", "0x90B6");
+      } else {
+        if (!(vendorFunctions == "user" || vendorFunctions == ""))
+          ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+        ret = setVidPid("0x18d1", "0x4ee4");
+      }
+      break;
+    case static_cast<uint64_t>(GadgetFunction::PTP):
+      if (!(vendorFunctions == "user" || vendorFunctions == ""))
+        ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+      ret = setVidPid("0x18d1", "0x4ee5");
+      break;
+    case GadgetFunction::ADB | GadgetFunction::PTP:
+      if (!(vendorFunctions == "user" || vendorFunctions == ""))
+        ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+      ret = setVidPid("0x18d1", "0x4ee6");
+      break;
+    case static_cast<uint64_t>(GadgetFunction::ADB):
+      if (vendorFunctions == "diag") {
+        ret = setVidPid("0x05C6", "0x901D");
+      } else if (vendorFunctions == "diag,serial_cdev,rmnet_gsi") {
+        ret = setVidPid("0x05C6", "0x9091");
+      } else if (vendorFunctions == "diag,serial_cdev") {
+        ret = setVidPid("0x05C6", "0x901F");
+      } else {
+        if (!(vendorFunctions == "user" || vendorFunctions == ""))
+          ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+        ret = setVidPid("0x18d1", "0x4ee7");
+      }
+      break;
+    case static_cast<uint64_t>(GadgetFunction::MIDI):
+      if (!(vendorFunctions == "user" || vendorFunctions == ""))
+        ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+      ret = setVidPid("0x18d1", "0x4ee8");
+      break;
+    case GadgetFunction::ADB | GadgetFunction::MIDI:
+      if (!(vendorFunctions == "user" || vendorFunctions == ""))
+        ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+      ret = setVidPid("0x18d1", "0x4ee9");
+      break;
+    case static_cast<uint64_t>(GadgetFunction::ACCESSORY):
+      if (!(vendorFunctions == "user" || vendorFunctions == ""))
+        ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+      ret = setVidPid("0x18d1", "0x2d00");
+      break;
+    case GadgetFunction::ADB | GadgetFunction::ACCESSORY:
+      if (!(vendorFunctions == "user" || vendorFunctions == ""))
+        ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+      ret = setVidPid("0x18d1", "0x2d01");
+      break;
+    case static_cast<uint64_t>(GadgetFunction::AUDIO_SOURCE):
+      if (!(vendorFunctions == "user" || vendorFunctions == ""))
+        ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+      ret = setVidPid("0x18d1", "0x2d02");
+      break;
+    case GadgetFunction::ADB | GadgetFunction::AUDIO_SOURCE:
+      if (!(vendorFunctions == "user" || vendorFunctions == ""))
+        ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+      ret = setVidPid("0x18d1", "0x2d03");
+      break;
+    case GadgetFunction::ACCESSORY | GadgetFunction::AUDIO_SOURCE:
+      if (!(vendorFunctions == "user" || vendorFunctions == ""))
+        ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+      ret = setVidPid("0x18d1", "0x2d04");
+      break;
+    case GadgetFunction::ADB | GadgetFunction::ACCESSORY |
+         GadgetFunction::AUDIO_SOURCE:
+      if (!(vendorFunctions == "user" || vendorFunctions == ""))
+        ALOGE("Invalid vendorFunctions set: %s", vendorFunctions.c_str());
+      ret = setVidPid("0x18d1", "0x2d05");
+      break;
+    default:
+      ALOGE("Combination not supported");
+      ret = Status::CONFIGURATION_NOT_SUPPORTED;
+  }
+  return ret;
+}
+
+V1_0::Status UsbGadget::setupFunctions(
+    uint64_t functions, const sp<V1_0::IUsbGadgetCallback> &callback,
+    uint64_t timeout) {
+  std::unique_lock<std::mutex> lk(mLock);
+
+  unique_fd inotifyFd(inotify_init());
+  if (inotifyFd < 0) {
+    ALOGE("inotify init failed");
+    return Status::ERROR;
+  }
+
+  bool ffsEnabled = false;
+  int i = 0;
+  std::string bootMode = GetProperty(PERSISTENT_BOOT_MODE, "");
+
+  if (((functions & GadgetFunction::MTP) != 0)) {
+    ffsEnabled = true;
+    ALOGI("setCurrentUsbFunctions mtp");
+    if (!WriteStringToFile("1", DESC_USE_PATH)) return Status::ERROR;
+
+    if (inotify_add_watch(inotifyFd, "/dev/usb-ffs/mtp/", IN_ALL_EVENTS) == -1)
+      return Status::ERROR;
+
+    if (linkFunction("ffs.mtp", i++)) return Status::ERROR;
+
+    // Add endpoints to be monitored.
+    mEndpointList.push_back("/dev/usb-ffs/mtp/ep1");
+    mEndpointList.push_back("/dev/usb-ffs/mtp/ep2");
+    mEndpointList.push_back("/dev/usb-ffs/mtp/ep3");
+  } else if (((functions & GadgetFunction::PTP) != 0)) {
+    ffsEnabled = true;
+    ALOGI("setCurrentUsbFunctions ptp");
+    if (!WriteStringToFile("1", DESC_USE_PATH)) return Status::ERROR;
+
+    if (inotify_add_watch(inotifyFd, "/dev/usb-ffs/ptp/", IN_ALL_EVENTS) == -1)
+      return Status::ERROR;
+
+
+    if (linkFunction("ffs.ptp", i++)) return Status::ERROR;
+
+    // Add endpoints to be monitored.
+    mEndpointList.push_back("/dev/usb-ffs/ptp/ep1");
+    mEndpointList.push_back("/dev/usb-ffs/ptp/ep2");
+    mEndpointList.push_back("/dev/usb-ffs/ptp/ep3");
+  }
+
+  if ((functions & GadgetFunction::MIDI) != 0) {
+    ALOGI("setCurrentUsbFunctions MIDI");
+    if (linkFunction("midi.gs5", i++)) return Status::ERROR;
+  }
+
+  if ((functions & GadgetFunction::ACCESSORY) != 0) {
+    ALOGI("setCurrentUsbFunctions Accessory");
+    if (linkFunction("accessory.gs2", i++)) return Status::ERROR;
+  }
+
+  if ((functions & GadgetFunction::AUDIO_SOURCE) != 0) {
+    ALOGI("setCurrentUsbFunctions Audio Source");
+    if (linkFunction("audio_source.gs3", i++)) return Status::ERROR;
+  }
+
+  if ((functions & GadgetFunction::RNDIS) != 0) {
+    ALOGI("setCurrentUsbFunctions rndis");
+    if (linkFunction("gsi.rndis", i++)) return Status::ERROR;
+  }
+
+  std::string vendorFunctions = getVendorFunctions();
+  if (vendorFunctions != "") {
+    ALOGI("enable usbradio debug functions");
+    char *function = strtok(const_cast<char *>(vendorFunctions.c_str()), ",");
+    while (function != NULL) {
+      if (string(function) == "diag" && linkFunction("diag.diag", i++))
+        return Status::ERROR;
+      if (string(function) == "serial_cdev" && linkFunction("cser.dun.0", i++))
+        return Status::ERROR;
+      if (string(function) == "rmnet_gsi" && linkFunction("gsi.rmnet", i++))
+        return Status::ERROR;
+      function = strtok(NULL, ",");
+    }
+  }
+
+  if ((functions & GadgetFunction::ADB) != 0) {
+    ffsEnabled = true;
+    ALOGI("setCurrentUsbFunctions Adb");
+    if (inotify_add_watch(inotifyFd, "/dev/usb-ffs/adb/", IN_ALL_EVENTS) == -1)
+      return Status::ERROR;
+
+    if (linkFunction("ffs.adb", i++)) return Status::ERROR;
+    mEndpointList.push_back("/dev/usb-ffs/adb/ep1");
+    mEndpointList.push_back("/dev/usb-ffs/adb/ep2");
+    ALOGI("Service started");
+  }
+
+  // Pull up the gadget right away when there are no ffs functions.
+  if (!ffsEnabled) {
+    if (!WriteStringToFile(GADGET_NAME, PULLUP_PATH)) return Status::ERROR;
+    mCurrentUsbFunctionsApplied = true;
+    if (callback)
+      callback->setCurrentUsbFunctionsCb(functions, Status::SUCCESS);
+    return Status::SUCCESS;
+  }
+
+  unique_fd eventFd(eventfd(0, 0));
+  if (eventFd == -1) {
+    ALOGE("mEventFd failed to create %d", errno);
+    return Status::ERROR;
+  }
+
+  unique_fd epollFd(epoll_create(2));
+  if (epollFd == -1) {
+    ALOGE("mEpollFd failed to create %d", errno);
+    return Status::ERROR;
+  }
+
+  if (addEpollFd(epollFd, inotifyFd) == -1) return Status::ERROR;
+
+  if (addEpollFd(epollFd, eventFd) == -1) return Status::ERROR;
+
+  mEpollFd = move(epollFd);
+  mInotifyFd = move(inotifyFd);
+  mEventFd = move(eventFd);
+  gadgetPullup = false;
+
+  // Monitors the ffs paths to pull up the gadget when descriptors are written.
+  // Also takes of the pulling up the gadget again if the userspace process
+  // dies and restarts.
+  mMonitor = unique_ptr<thread>(new thread(monitorFfs, this));
+  mMonitorCreated = true;
+  if (DEBUG) ALOGI("Mainthread in Cv");
+
+  if (callback) {
+    if (mCv.wait_for(lk, timeout * 1ms, [] { return gadgetPullup; })) {
+      ALOGI("monitorFfs signalled true");
+    } else {
+      ALOGI("monitorFfs signalled error");
+      // continue monitoring as the descriptors might be written at a later
+      // point.
+    }
+    Return<void> ret = callback->setCurrentUsbFunctionsCb(
+        functions, gadgetPullup ? Status::SUCCESS : Status::ERROR);
+    if (!ret.isOk())
+      ALOGE("setCurrentUsbFunctionsCb error %s", ret.description().c_str());
+  }
+
+  return Status::SUCCESS;
+}
+
+Return<void> UsbGadget::setCurrentUsbFunctions(
+    uint64_t functions, const sp<V1_0::IUsbGadgetCallback> &callback,
+    uint64_t timeout) {
+  std::unique_lock<std::mutex> lk(mLockSetCurrentFunction);
+
+  mCurrentUsbFunctions = functions;
+  mCurrentUsbFunctionsApplied = false;
+
+  // Unlink the gadget and stop the monitor if running.
+  V1_0::Status status = tearDownGadget();
+  if (status != Status::SUCCESS) {
+    goto error;
+  }
+
+  ALOGI("Returned from tearDown gadget");
+
+  // Leave the gadget pulled down to give time for the host to sense disconnect.
+  usleep(DISCONNECT_WAIT_US);
+
+  if (functions == static_cast<uint64_t>(GadgetFunction::NONE)) {
+    if (callback == NULL) return Void();
+    Return<void> ret =
+        callback->setCurrentUsbFunctionsCb(functions, Status::SUCCESS);
+    if (!ret.isOk())
+      ALOGE("Error while calling setCurrentUsbFunctionsCb %s",
+            ret.description().c_str());
+    return Void();
+  }
+
+  status = validateAndSetVidPid(functions);
+
+  if (status != Status::SUCCESS) {
+    goto error;
+  }
+
+  status = setupFunctions(functions, callback, timeout);
+  if (status != Status::SUCCESS) {
+    goto error;
+  }
+
+  ALOGI("Usb Gadget setcurrent functions called successfully");
+  return Void();
+
+error:
+  ALOGI("Usb Gadget setcurrent functions failed");
+  if (callback == NULL) return Void();
+  Return<void> ret = callback->setCurrentUsbFunctionsCb(functions, status);
+  if (!ret.isOk())
+    ALOGE("Error while calling setCurrentUsbFunctionsCb %s",
+          ret.description().c_str());
+  return Void();
+}
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace gadget
+}  // namespace usb
+}  // namespace hardware
+}  // namespace android
diff --git a/usb/UsbGadget.h b/usb/UsbGadget.h
new file mode 100644
index 0000000..a0aa42b
--- /dev/null
+++ b/usb/UsbGadget.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_HARDWARE_USB_GADGET_V1_0_USBGADGET_H
+#define ANDROID_HARDWARE_USB_GADGET_V1_0_USBGADGET_H
+
+#include <android-base/file.h>
+#include <android-base/properties.h>
+#include <android-base/unique_fd.h>
+#include <android/hardware/usb/gadget/1.0/IUsbGadget.h>
+#include <hidl/MQDescriptor.h>
+#include <hidl/Status.h>
+#include <string>
+#include <sys/epoll.h>
+#include <sys/eventfd.h>
+#include <thread>
+#include <utils/Log.h>
+#include <chrono>
+#include <condition_variable>
+#include <mutex>
+
+namespace android {
+namespace hardware {
+namespace usb {
+namespace gadget {
+namespace V1_0 {
+namespace implementation {
+
+using ::android::sp;
+using ::android::base::GetProperty;
+using ::android::base::SetProperty;
+using ::android::base::unique_fd;
+using ::android::base::WriteStringToFile;
+using ::android::hardware::hidl_array;
+using ::android::hardware::hidl_memory;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+using ::std::chrono::steady_clock;
+using ::std::lock_guard;
+using ::std::move;
+using ::std::mutex;
+using ::std::string;
+using ::std::thread;
+using ::std::unique_ptr;
+using ::std::vector;
+using namespace std::chrono;
+using namespace std::chrono_literals;
+
+struct UsbGadget : public IUsbGadget {
+  UsbGadget();
+  unique_fd mInotifyFd;
+  unique_fd mEventFd;
+  unique_fd mEpollFd;
+
+  unique_ptr<thread> mMonitor;
+  volatile bool mMonitorCreated;
+  vector<string> mEndpointList;
+  // protects the CV.
+  std::mutex mLock;
+  std::condition_variable mCv;
+
+  // Makes sure that only one request is processed at a time.
+  std::mutex mLockSetCurrentFunction;
+  uint64_t mCurrentUsbFunctions;
+  bool mCurrentUsbFunctionsApplied;
+
+  Return<void> setCurrentUsbFunctions(uint64_t functions,
+                                      const sp<IUsbGadgetCallback>& callback,
+                                      uint64_t timeout) override;
+
+  Return<void> getCurrentUsbFunctions(
+      const sp<IUsbGadgetCallback>& callback) override;
+
+  private:
+  Status tearDownGadget();
+  Status setupFunctions(uint64_t functions,
+                        const sp<IUsbGadgetCallback>& callback,
+                        uint64_t timeout);
+};
+
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace gadget
+}  // namespace usb
+}  // namespace hardware
+}  // namespace android
+
+#endif  // ANDROID_HARDWARE_USB_V1_2_USBGADGET_H
diff --git a/usb/android.hardware.usb@1.0-service.xiaomi_sdm660.rc b/usb/android.hardware.usb@1.0-service.xiaomi_sdm660.rc
deleted file mode 100644
index 6b61b8e..0000000
--- a/usb/android.hardware.usb@1.0-service.xiaomi_sdm660.rc
+++ /dev/null
@@ -1,4 +0,0 @@
-service usb-hal-1-0 /vendor/bin/hw/android.hardware.usb@1.0-service.xiaomi_sdm660
-    class hal
-    user system
-    group system
diff --git a/usb/android.hardware.usb@1.1-service.xiaomi_sdm660.rc b/usb/android.hardware.usb@1.1-service.xiaomi_sdm660.rc
new file mode 100644
index 0000000..485ca8d
--- /dev/null
+++ b/usb/android.hardware.usb@1.1-service.xiaomi_sdm660.rc
@@ -0,0 +1,12 @@
+service vendor.usb-hal-1-1 /vendor/bin/hw/android.hardware.usb@1.1-service.xiaomi_sdm660
+    class hal
+    user root
+    group root system shell mtp
+
+on boot
+    chown root system /sys/class/typec/port0/power_role
+    chown root system /sys/class/typec/port0/data_role
+    chown root system /sys/class/typec/port0/port_type
+    chmod 664 /sys/class/typec/port0/power_role
+    chmod 664 /sys/class/typec/port0/data_role
+    chmod 664 /sys/class/typec/port0/port_type
diff --git a/usb/service.cpp b/usb/service.cpp
index 45b60d5..bc12f77 100644
--- a/usb/service.cpp
+++ b/usb/service.cpp
@@ -1,31 +1,24 @@
 /*
-#
-# Copyright (C) 2018 The Xiaomi-SDM660 Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-#
-# This file sets variables that control the way modules are built
-# thorughout the system. It should not be used to conditionally
-# disable makefiles (the proper mechanism to control what gets
-# included in a build is to use PRODUCT_PACKAGES in a product
-# definition file).
-#
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
-#include <android-base/logging.h>
+#define LOG_TAG "android.hardware.usb@1.1-service.xiaomi_sdm660"
+
 #include <hidl/HidlTransportSupport.h>
 #include "Usb.h"
+#include "UsbGadget.h"
 
 using android::sp;
 
@@ -34,23 +27,37 @@ using android::hardware::configureRpcThreadpool;
 using android::hardware::joinRpcThreadpool;
 
 // Generated HIDL files
-using android::hardware::usb::V1_0::IUsb;
-using android::hardware::usb::V1_0::implementation::Usb;
+using android::hardware::usb::V1_1::IUsb;
+using android::hardware::usb::gadget::V1_0::IUsbGadget;
+using android::hardware::usb::V1_1::implementation::Usb;
+using android::hardware::usb::gadget::V1_0::implementation::UsbGadget;
+
+using android::OK;
+using android::status_t;
 
 int main() {
     android::sp<IUsb> service = new Usb();
+    android::sp<IUsbGadget> service2 = new UsbGadget();
 
-    configureRpcThreadpool(1, true /*callerWillJoin*/);
-    android::status_t status = service->registerAsService();
+    configureRpcThreadpool(2, true /*callerWillJoin*/);
+    status_t status = service->registerAsService();
 
-    if (status != android::OK) {
-        LOG(ERROR) << "Cannot register USB HAL service";
+    if (status != OK) {
+        ALOGE("Cannot register USB HAL service");
         return 1;
     }
 
-    LOG(INFO) << "USB HAL Ready.";
+    status = service2->registerAsService();
+
+    if (status != OK) {
+        ALOGE("Cannot register USB Gadget HAL service");
+        return 1;
+    }
+
+    ALOGI("USB HAL Ready.");
     joinRpcThreadpool();
     // Under noraml cases, execution will not reach this line.
-    LOG(ERROR) << "USB HAL failed to join thread pool.";
+    ALOGI("USB HAL failed to join thread pool.");
     return 1;
+
 }
